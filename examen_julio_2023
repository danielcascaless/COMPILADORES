**Ejercicio 1: Propiedades que impiden que una gramÃ¡tica sea LL(1)**

---

### ğŸ“ Enunciado:

La gramÃ¡tica Gâ‚ estÃ¡ definida por:

```
(1) S â†’ i = A
(2) A â†’ A = A
(3) A â†’ i
(4) A â†’ (A)
```

Esta gramÃ¡tica representa sentencias de asignaciÃ³n donde el operador `=` es asociativo por la derecha. Se pregunta si tiene alguna propiedad que impida que sea LL(1).

---

### ğŸ” AnÃ¡lisis:

La producciÃ³n:

```
A â†’ A = A
```

provoca dos problemas que impiden que la gramÃ¡tica sea LL(1):

#### ğŸ” 1. Recursividad por la izquierda

* Esta regla se refiere a sÃ­ misma en la primera posiciÃ³n, lo que impide construir una tabla LL(1).
* Ejemplo: al analizar `A`, se entra en `A â†’ A = A` y vuelve a `A` sin consumir ningÃºn terminal.

#### â— 2. AmbigÃ¼edad

* Una cadena como `i = i = i` puede derivarse de varias formas dependiendo de cÃ³mo se agrupen los operadores `=`.
* Esto genera mÃºltiples Ã¡rboles de derivaciÃ³n para la misma cadena.

---

### âœ… ConclusiÃ³n

La gramÃ¡tica **NO es LL(1)** porque:

* Tiene **recursividad por la izquierda**.
* Es **ambigua**, ya que admite mÃ¡s de un Ã¡rbol de derivaciÃ³n para ciertas entradas.

Para que pudiera ser LL(1), se necesitarÃ­a eliminar ambos problemas con una transformaciÃ³n adecuada.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

**Ejercicio 2: TransformaciÃ³n para hacer la gramÃ¡tica LL(1)**

---

### ğŸ“ Enunciado:

Teniendo en cuenta la asociatividad del operador `=`, realiza las transformaciones necesarias para que la gramÃ¡tica **G1** del ejercicio anterior se convierta en una gramÃ¡tica **G1'** que pueda analizarse con el mÃ©todo LL(1).

---

### ğŸ”„ Paso 1: Eliminar la ambigÃ¼edad

El operador `=` es **asociativo por la derecha**, por lo tanto hay que reescribir las reglas de forma que reflejen esto y eviten la recursividad por la izquierda.

Transformamos:

```
S â†’ i = A
A â†’ F = A | F
F â†’ i | (A)
```

Ahora `A` no tiene recursividad por la izquierda. Aun asÃ­, la producciÃ³n `A â†’ F = A | F` comparte un prefijo `F`, lo que requiere **eliminaciÃ³n de factores comunes**.

---

### âœï¸ Paso 2: Eliminar factores comunes

Aplicamos factorizaciÃ³n:

```
A â†’ F A'
A' â†’ = A | Î»
```

Quedando la gramÃ¡tica transformada como:

```
(1) S  â†’ i = A
(2) A  â†’ F A'
(3) A' â†’ = A
(4) A' â†’ Î»
(5) F  â†’ i
(6) F  â†’ (A)
```

---

### âœ… ConclusiÃ³n

Esta nueva gramÃ¡tica **G1'**:

* Elimina la **ambigÃ¼edad**.
* Es **equivalente** a G1 en significado.
* Es apta para construcciÃ³n de tabla LL(1), ya que no tiene ni recursividad por la izquierda ni factores comunes.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

**Ejercicio 3: CÃ¡lculo de PRIMERO, SIGUIENTE y PREDICT**

---

### ğŸ“ Enunciado:

A partir de la gramÃ¡tica transformada G1':

```
(1) S  â†’ i = A
(2) A  â†’ F A'
(3) A' â†’ = A
(4) A' â†’ Î»
(5) F  â†’ i
(6) F  â†’ (A)
```

Calcular los conjuntos **PRIMERO**, **SIGUIENTE** y **PREDICT** de todos los no terminales.

---

### ğŸ”¢ Conjuntos PRIMERO

```
PRIMERO(S)  = { i }
PRIMERO(A)  = { i, ( }
PRIMERO(A') = { =, Î» }
PRIMERO(F)  = { i, ( }
```

* `S` deriva a `i` directamente.
* `A` comienza en `F`, que puede ser `i` o `(`.
* `A'` tiene una producciÃ³n con `=` y una vacÃ­a (`Î»`).

---

### ğŸ” Conjuntos SIGUIENTE

```
SIGUIENTE(S)  = { $ }
SIGUIENTE(A)  = { $ }
SIGUIENTE(A') = { $ }
SIGUIENTE(F)  = { =, $ }
```

* `S` es el sÃ­mbolo inicial, por eso su SIGUIENTE contiene `$`.
* `A` aparece en la derecha de `S â†’ i = A`, por lo tanto hereda SIGUIENTE(S).
* `A'` aparece justo despuÃ©s de `F` en `A â†’ F A'`, por lo que hereda SIGUIENTE(A).
* `F` estÃ¡ antes de `A'`, pero como `A'` puede ser `Î»`, F hereda SIGUIENTE(A) tambiÃ©n.

---

### ğŸ“Œ Conjuntos PREDICT

Se calcula con la fÃ³rmula:

```
PREDICT(X â†’ Î±) = PRIMERO(Î±) âˆª (SIGUIENTE(X) si Î» âˆˆ PRIMERO(Î±))
```

```
PREDICT(1) = { i }
PREDICT(2) = { i, ( }
PREDICT(3) = { = }
PREDICT(4) = { $ }
PREDICT(5) = { i }
PREDICT(6) = { ( }
```

---

### âœ… ConclusiÃ³n

Los conjuntos PRIMERO, SIGUIENTE y PREDICT estÃ¡n correctamente definidos para construir la tabla LL(1) sin conflictos.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

**Ejercicio 4: Tabla de anÃ¡lisis LL(1)**

---

### ğŸ“ Enunciado:

A partir de la gramÃ¡tica Gâ‚':

```
(1) S  â†’ i = A
(2) A  â†’ F A'
(3) A' â†’ = A
(4) A' â†’ Î»
(5) F  â†’ i
(6) F  â†’ (A)
```

Se pide construir la tabla de anÃ¡lisis LL(1) y razonar si Gâ‚' es LL(1).

---

### ğŸ“Š Tabla LL(1)

| NO TERM | i | = | ( | ) | \$ |
| ------- | - | - | - | - | -- |
| S       | 1 |   |   |   |    |
| A       | 2 |   | 2 |   |    |
| A'      |   | 3 |   | 4 | 4  |
| F       | 5 |   | 6 |   |    |

InterpretaciÃ³n:

* Las celdas contienen el nÃºmero de regla que se aplica segÃºn el terminal.
* Ejemplo: para A con entrada `i`, se aplica la regla (2) porque PRIMERO(F A') = { i, ( }.

---

### âœ… ConclusiÃ³n

* La tabla **no tiene conflictos**: cada celda contiene **como mÃ¡ximo una regla**.
* Por tanto, podemos afirmar que la gramÃ¡tica **Gâ‚' es LL(1)**.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

**Ejercicio 5: ColecciÃ³n LR(1) y cÃ¡lculos de GOTO**

---

### ğŸ“ Enunciado:

Se da la gramÃ¡tica Gâ‚‚ con:

```
(1) S â†’ A B
(2) S' â†’ B
(3) S â†’ C a
(4) A â†’ b B a
(5) B â†’ A
(6) B â†’ b
(7) C â†’ A
```

Se pide:

* Calcular los conjuntos de items LR(1) Iâ‚€, Iâ‚…, Iâ‚†.
* Calcular los GOTO que faltan.

---

### ğŸ“¦ Conjuntos LR(1)

**Iâ‚€ =**

```
{ S' â†’ Â· S , $ }
{ S â†’ Â· A B , $ }
{ S â†’ Â· B , $ }
{ S â†’ Â· C a , $ }
{ A â†’ Â· b B a , $/a }
{ B â†’ Â· A , $ }
{ B â†’ Â· b , $ }
{ C â†’ Â· A , a }
```

**Iâ‚… = GOTO(Iâ‚€, b) =**

```
{ A â†’ b Â· B a , $/b/$/a }
{ B â†’ Â· b , $ }
{ B â†’ Â· A , $ }
{ B â†’ Â· b , a }
{ B â†’ Â· A , a }
{ A â†’ Â· b B a , a }
```

**Iâ‚† = GOTO(Iâ‚‚, B) =**

```
{ S â†’ A B Â· , $ }
```

---

### ğŸ” GOTO faltantes

SegÃºn la tabla final, se deducen los siguientes GOTO:

```
GOTO(Iâ‚ˆ, b) = Iâ‚â‚‚
GOTO(Iâ‚ˆ, A) = Iâ‚â‚
GOTO(Iâ‚‚, b) = Iâ‚â‚‚
GOTO(Iâ‚‚, A) = Iâ‚â‚
```

---

### âœ… ConclusiÃ³n

Los conjuntos LR(1) y los GOTO adicionales calculados completan la colecciÃ³n hasta donde se pedÃ­a, manteniendo la consistencia de los accesos entre estados.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

**Ejercicio 6: Filas de la tabla LR-CanÃ³nica**

---

### ğŸ“ Enunciado:

Se pide completar las filas correspondientes a los estados 2, 5 y 14 de la **tabla LR-CanÃ³nica** de la gramÃ¡tica Gâ‚‚.

---

### ğŸ“‹ Tabla (fragmento de filas requeridas)

| Estado | ACCIÃ“N (a) | ACCIÃ“N (b) | ACCIÃ“N (\$) | IR-A (S) | IR-A (A) | IR-A (B) | IR-A (C) |
| ------ | ---------- | ---------- | ----------- | -------- | -------- | -------- | -------- |
| 2      | r7         | d8         | r5          |          | 7        | 6        |          |
| 5      |            | d12        | r6          |          | 11       | 10       |          |
| 14     | r4         | r4         | r4          |          |          |          |          |

---

### ğŸ§  JustificaciÃ³n:

* **Estado 2**:

  * Contiene item `C â†’ Â· A , a`, y `B â†’ Â· b , $`.
  * Reduce con `B â†’ b` en `$`, y `C â†’ A` en `a`, por tanto `r5` y `r7` aparecen.
  * Desde aquÃ­ se puede hacer GOTO a `S â†’ A B` â†’ estados 7 y 6.

* **Estado 5**:

  * Tiene `A â†’ b Â· B a` como nÃºcleo. Desde aquÃ­ se puede desplazar con `a` a `d12`.
  * Si `B â†’ A` o `B â†’ b` son completados en este estado, se va a estados 11 y 10.

* **Estado 14**:

  * Contiene item `A' â†’ Î» , {a, b, $}` (por ejemplo), con lo cual reduce por la regla 4 para todos esos terminales.

---

### âœ… ConclusiÃ³n

Las filas de la tabla LR-CanÃ³nica estÃ¡n correctamente determinadas para los estados 2, 5 y 14, de acuerdo con los items LR(1) que contienen y las transiciones posibles por terminales y no terminales.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

**Ejercicio 7: AgrupaciÃ³n de conjuntos para colecciÃ³n LALR**

---

### ğŸ“ Enunciado:

Se pide indicar quÃ© conjuntos de items LR(1) se deben **agrupar** para formar la colecciÃ³n **LALR**, y cuÃ¡l es su contenido.

Esto se basa en agrupar los **conjuntos con el mismo nÃºcleo**, es decir, mismos items sin mirar los lookahead.

---

### ğŸ“¦ Agrupaciones de conjuntos

#### Iâ‚…, Iâ‚ˆ, Iâ‚â‚‚:

```
{ A â†’ b Â· B a , b/$/a }
{ B â†’ Â· b , $/a }
{ B â†’ Â· A , a }
{ B â†’ Â· b , a }
{ A â†’ Â· b B a , a }
```

#### Iâ‚â‚€, Iâ‚â‚ƒ, Iâ‚â‚…:

```
{ A â†’ b B Â· a , b/$/a }
```

#### Iâ‚‡, Iâ‚â‚:

```
{ B â†’ A Â· , $/a }
```

#### Iâ‚â‚„, Iâ‚â‚†, Iâ‚â‚‡:

```
{ A â†’ b B a Â· , b/$/a }
```

---

### âœ… ConclusiÃ³n

* Los conjuntos con el mismo nÃºcleo pero distintos lookahead se **fusionan**.
* El resultado es una colecciÃ³n **mÃ¡s compacta** de estados.
* Esto permite reducir el tamaÃ±o de la tabla manteniendo la capacidad de reconocimiento.

âœ… AsÃ­ se construye correctamente la colecciÃ³n LALR.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

**Ejercicio 8: ClasificaciÃ³n de la gramÃ¡tica como LR-CanÃ³nica, LALR y/o SLR**

---

### ğŸ“ Enunciado:

Justifica si la gramÃ¡tica es:

* **LR-CanÃ³nica (LR(1))**
* **LALR(1)**
* **SLR(1)**

---

### ğŸ” AnÃ¡lisis

#### âœ… LR-CanÃ³nica:

Analizando la colecciÃ³n LR(1) del **Ejercicio 5**, los estados con acciones de reducciÃ³n y desplazamiento **no presentan conflictos** `r/r` ni `d/r`.

* Ejemplo: los estados Iâ‚‚, Iâ‚…, Iâ‚ˆ e Iâ‚â‚‚ estÃ¡n bien definidos y no hay ambigÃ¼edad.
* Por tanto, **la gramÃ¡tica es LR-CanÃ³nica**.

#### âœ… LALR:

En el **Ejercicio 7**, al agrupar los estados con el mismo nÃºcleo, tampoco se producen conflictos `r/r`.

* La compactaciÃ³n de la colecciÃ³n no genera ambigÃ¼edad.
* Por tanto, **la gramÃ¡tica tambiÃ©n es LALR**.

#### âŒ SLR:

Analizando el estado Iâ‚‚ y considerando que:

* SIGUIENTE(B) = { \$, a }
* SIGUIENTE(C) = { a }

En la colecciÃ³n SLR, los items:

* `B â†’ A Â·` y `C â†’ A Â·` coinciden con el mismo lookahead `a`, produciendo **un conflicto `r/r`**.

Por tanto, **la gramÃ¡tica no es SLR(1)**.

---

### âœ… ConclusiÃ³n

* âœ”ï¸ Es **LR-CanÃ³nica** âœ…
* âœ”ï¸ Es **LALR(1)** âœ…
* âŒ No es **SLR(1)** âŒ

---

