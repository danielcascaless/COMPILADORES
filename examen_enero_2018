**Resoluci√≥n paso a paso del examen de Compiladores - Enero 2018**

---

### ü§î Ejercicio 1: Transformaci√≥n de gram√°tica (Eliminaci√≥n de recursividad + Factorizaci√≥n)

#### ‚úèÔ∏è Enunciado:

Indica las caracter√≠sticas que tiene la gram√°tica G que impiden que sea LL(1). Modif√≠cala adecuadamente.

#### üîÑ Paso 1: Analizar la gram√°tica original

```
E  ‚Üí E + E | E - E | E ! | N
N  ‚Üí 0 | s(N)
```

Esta gram√°tica tiene dos problemas que impiden que sea LL(1):

1. **Recursividad por la izquierda**: las tres primeras reglas de `E` comienzan con `E`, lo que hace que se entre en bucle al intentar analizar predictivamente.
2. **Factores comunes**: todas esas reglas empiezan con el mismo s√≠mbolo (E), lo que impide decidir la producci√≥n con solo mirar el siguiente token.

#### üéì Teor√≠a:

* Un analizador **LL(1)** necesita que con **una mirada (1 token)** sepamos qu√© producci√≥n usar.
* La **recursividad por la izquierda** rompe esto porque genera una expansi√≥n infinita sin consumir entrada.

#### üéì ¬øC√≥mo se elimina?

Para cualquier regla del tipo: `A ‚Üí AŒ± | Œ≤`, se reescribe como:

```
A  ‚Üí Œ≤ A'
A' ‚Üí Œ± A' | Œª
```

#### üéì ¬øC√≥mo se factoriza?

Cuando hay reglas como: `A ‚Üí Œ±Œ≤1 | Œ±Œ≤2`, se reescriben como:

```
A  ‚Üí Œ± A'
A' ‚Üí Œ≤1 | Œ≤2
```

#### üìö Aplicamos a la gram√°tica:

1. Eliminamos la recursividad por la izquierda:

```
E  ‚Üí N E'
E' ‚Üí + E | - E | ! | Œª
```

2. Factorizamos para reagrupar estructuras comunes (prefijos de operador):

```
E' ‚Üí + E E' | - E E' | ! E' | Œª
```

3. Gram√°tica resultante:

```
E  ‚Üí N E'
E' ‚Üí + E E' | - E E' | ! E' | Œª
N  ‚Üí 0 | s(N)
```

‚úÖ Esta gram√°tica ya es apta para LL(1): no hay ambig√ºedad ni recursividad por la izquierda.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


### üß† Ejercicio 2: C√°lculo de PRIMERO, SIGUIENTE y tabla LL(1)

#### üéì Teor√≠a:

* **PRIMERO(X)**: conjunto de terminales que pueden iniciar derivaciones desde X.
* **SIGUIENTE(X)**: conjunto de terminales que pueden aparecer justo despu√©s de X en alguna derivaci√≥n.
* Se usan para construir la **tabla de an√°lisis LL(1)**.

#### üî¢ Paso 1: C√°lculo de PRIMERO

```
PRIMERO(E) = PRIMERO(N) = { 0, s }
PRIMERO(E') = { +, -, !, Œª }
PRIMERO(E'') = { +, - }
```

#### üîç Paso 2: C√°lculo de SIGUIENTE

```
SIGUIENTE(E) = { +, -, !, $ }
SIGUIENTE(E') = { +, -, !, $ }
SIGUIENTE(E'') = { +, -, !, $ }
SIGUIENTE(N) = { +, -, !, $ }
```

#### üìä Paso 3: Tabla LL(1)

Usamos: `PREDICT(A ‚Üí Œ±) = PRIMERO(Œ±) ‚à™ (SIGUIENTE(A) si Œ± ‚áí Œª)`

| NO TERM | +          | -          | !        | 0          | s          | ( | ) | \$     |
| ------- | ---------- | ---------- | -------- | ---------- | ---------- | - | - | ------ |
| E       |            |            |          | E ‚Üí N E'   | E ‚Üí N E'   |   |   |        |
| E'      | E' ‚Üí Œª     | E' ‚Üí Œª     | E' ‚Üí !E' | E' ‚Üí E E'' | E' ‚Üí E E'' |   |   | E' ‚Üí Œª |
| E''     | E'' ‚Üí + E' | E'' ‚Üí - E' |          |            |            |   |   |        |
| N       |            |            |          | N ‚Üí 0      | N ‚Üí s(N)   |   |   |        |

‚úÖ Como se puede observar, no hay conflictos en la tabla y, por tanto, la gram√°tica es **LL(1)**.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
**Ejercicio 3: Comprobaci√≥n de SLR(1)**

---

### üéì Teor√≠a:

* Un analizador SLR(1) se basa en construir una **colecci√≥n de conjuntos de items LR(0)**.
* Cada item tiene la forma `A ‚Üí Œ± ¬∑ Œ≤`, donde el punto indica lo que ya se ha reconocido.
* Se usa el conjunto **SIGUIENTE** para saber en qu√© columnas insertar reducciones.

Una tabla SLR es v√°lida si **no hay conflictos** (por ejemplo, shift/reduce o reduce/reduce en una misma celda).

---

### üõ†Ô∏è Paso 1: Colecci√≥n de conjuntos LR(0)

Se construyen los conjuntos de items paso a paso, con GOTO y CLOSURE.

```
I0 = { E' ‚Üí ¬∑ E, E ‚Üí ¬∑ E + E, E ‚Üí ¬∑ E - E, E ‚Üí ¬∑ E !, E ‚Üí ¬∑ N, N ‚Üí ¬∑ 0, N ‚Üí ¬∑ s ( N ) }
```

Desde I0, aplicamos GOTO por los s√≠mbolos posibles:

```
GOTO(I0, E) = I1 = { E' ‚Üí E ¬∑ }
GOTO(I0, N) = I2 = { E ‚Üí N ¬∑ }
GOTO(I0, 0) = I3 = { N ‚Üí 0 ¬∑ }
GOTO(I0, s) = I4 = { N ‚Üí s ¬∑ ( N ) }
GOTO(I4, () = I5 = { N ‚Üí s ( ¬∑ N ) }
GOTO(I5, N) = I6 = { N ‚Üí s ( N ¬∑ ) }
GOTO(I6, )) = I7 = { N ‚Üí s ( N ) ¬∑ }
```

Y as√≠ sucesivamente hasta generar todos los estados necesarios.

Los conjuntos SIGUIENTE se usan para las reducciones:

```
SIGUIENTE(E) = { 0, s, +, -, !, $ }
SIGUIENTE(N) = { 0, s, +, -, !, $ }
```

---

### üìà Paso 2: Tabla de an√°lisis SLR(1)

La tabla resultante se construye enumerando las reglas por orden de aparici√≥n y completando la tabla con las acciones de desplazamiento (`d#`), reducci√≥n (`r#`), aceptaci√≥n (`acep`) e IR-A.

| Estado | +  | -  | !  | 0  | s  | (  | )   | \$   | E | N  |
| ------ | -- | -- | -- | -- | -- | -- | --- | ---- | - | -- |
| 0      |    |    |    | d3 | d4 |    |     |      | 1 | 2  |
| 1      |    |    | d6 | d3 |  d4|    |     | acep | 5 | 2  |
| 2      | r4 | r4 | r4 | r4 | r4 |    |     | r4   |   |    |
| 3      | r5 | r5 | r5 | r5 | r5 |    |  r5 | r5   |   |    |
| 4      |    |    |    |    |    | d7 |     |      |   |    |
| 5      | d8 | d9 | d6 | d3 | d4 |    |     |      | 5 | 2  |
| 6      | r3 | r3 | r3 | r3 | r3 |    |     | r3   |   |    |
| 7      |    |    |    | d3 | d4 |    |     |      |   | 10 |
| 8      | r1 | r1 | r1 | r1 | r1 |    |     | r1   |   |    |
| 9      | r2 | r2 | r2 | r2 | r2 |    |     | r2   |   |    |
| 10     |    |    |    |    |    |    | d11 |      |   |    |
| 11     | r6 | r6 | r6 | r6 | r6 |    |  r6 | r6   |   |    |

* `r1`: E ‚Üí E + E
* `r2`: E ‚Üí E - E
* `r3`: E ‚Üí E !
* `r4`: E ‚Üí N
* `r5`: N ‚Üí 0
* `r6`: N ‚Üí s(N)

---

### ‚úÖ Conclusi√≥n:

Como no hay conflictos en la tabla (cada celda tiene una sola acci√≥n v√°lida), **la gram√°tica es SLR(1)**.

Esta comprobaci√≥n implica tambi√©n que la gram√°tica ser√° LALR(1) y LR(1), porque:

```
SLR(1) ‚äÜ LALR(1) ‚äÜ LR(1)
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

**Ejercicio 4: Comprobaci√≥n de LR(1) y LALR(1)**

---

### üéì Teor√≠a previa

En la jerarqu√≠a de gram√°ticas descendentes y ascendentes, las clases de gram√°ticas se relacionan as√≠:

```
LR(1) ‚äá LALR(1) ‚äá SLR(1)
```

Esto significa que:

* Si una gram√°tica es **SLR(1)**, entonces **tambien es LALR(1)** y **LR(1)**.
* LALR(1) es una simplificaci√≥n de LR(1) que mantiene el poder de reconocimiento de muchas gram√°ticas sin requerir tanto espacio en la tabla.

Por lo tanto, **no hace falta construir nuevas colecciones** si ya sabemos que es SLR(1). Se deduce directamente.

---

### üìÖ Paso 1: Comprobar si ya hemos demostrado que es SLR(1)

En el ejercicio anterior (Ejercicio 3), se construy√≥ correctamente la tabla SLR(1) y se comprob√≥ que:

* No hay conflictos
* La tabla es determinista

Por definici√≥n:

> Toda gram√°tica que sea SLR(1) tambi√©n es LALR(1) y LR(1).

---

### ‚úÖ Conclusi√≥n final:

‚úÖ **La gram√°tica es LR(1)**
‚úÖ **La gram√°tica es LALR(1)**

Justificaci√≥n: porque **ya hemos comprobado que es SLR(1)**, y eso implica directamente que tambi√©n pertenece a las clases superiores.

No es necesario construir nuevas tablas ni colecciones adicionales.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


**Ejercicio 5: An√°lisis de entrada con tratamiento de errores (modo p√°nico)**

---

### üéì Teor√≠a previa: modo p√°nico

El **modo p√°nico** es una estrategia de **recuperaci√≥n de errores** en los analizadores sint√°cticos.

Cuando se detecta un error en la entrada (por ejemplo, un token inesperado), el analizador:

1. **Descarta s√≠mbolos** de la pila hasta encontrar un estado estable.
2. **Descarta tokens** de la entrada hasta hallar uno que pertenezca al conjunto de sincronizaci√≥n.
3. Luego **reanuda el an√°lisis** en ese punto.

Esto evita que el an√°lisis se detenga por completo tras el primer error y permite detectar m√°s errores en una sola pasada.

---

### üîÑ Entrada a analizar: `s(0)+`

Vamos a simular el proceso de an√°lisis sint√°ctico usando la **tabla SLR(1)** con modo p√°nico.

La entrada est√° en notaci√≥n postfija. Se a√±ade el s√≠mbolo de fin de entrada `$`:
**`s ( 0 ) + $`**

---

### ‚úèÔ∏è Simulaci√≥n paso a paso:

| **PILA**            | **ENTRADA** | **ACCI√ìN**                                    |
| ------------------- | ----------- | --------------------------------------------- |
| 0                   | s(0)+\$     | d4                                            |
| 0 s 4               | (0)+\$      | d7                                            |
| 0 s 4 ( 7           | 0)+\$       | d3                                            |
| 0 s 4 ( 7 0 3       | )+\$        | r5: N ‚Üí 0                                     |
| 0 s 4 ( 7 N 10      | )+\$        | d11                                           |
| 0 s 4 ( 7 N 10 ) 11 | +\$         | r6: N ‚Üí s(N)                                  |
| 0 N 2               | +\$         | r4: E ‚Üí N                                     |
| 0 E 1               | +\$         | Error: apilar E con IR-A\[1,E]=5 y continuar. |
| 0 E 1 E 5           | +\$         | d8                                            |
| 0 E 1 E 5 + 8       | \$          | r1: E ‚Üí E + E                                 |
| 0 E 1               | \$          | Finalizar: entrada no aceptada.               |


---

### ‚úÖ Conclusi√≥n

* La entrada `s(0)+` **no es aceptada** inicialmente.
* Se recupera usando el modo p√°nico y se puede continuar el an√°lisis.
* La gram√°tica permite **detectar errores y seguir analizando** gr√°ficamente.

Esto muestra la utilidad del tratamiento de errores en compiladores para mejorar la retroalimentaci√≥n al programador.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

**Ejercicio 6: Comprobaci√≥n de ambig√ºedad**

---

### üéì Teor√≠a previa: ambig√ºedad gramatical

Una **gram√°tica es ambigua** si existe **al menos una cadena** para la cual se pueden construir **dos √°rboles de derivaci√≥n distintos** (o tablas de parsing con conflictos).

Indicadores comunes de ambig√ºedad:

* El mismo string se puede derivar con diferentes estructuras sint√°cticas.
* La tabla de an√°lisis (LL(1), LR(1), SLR...) tiene **conflictos**.

---

### üîÑ Comprobaci√≥n en este caso

Ya hemos construido en el Ejercicio 3 la tabla **SLR(1)** y observamos que:

* No tiene conflictos (ni shift/reduce ni reduce/reduce).
* Cada celda contiene una sola acci√≥n.

Esto es evidencia formal de que la gram√°tica **no es ambigua**.

---

### ‚úÖ Justificaci√≥n adicional

En este caso, la notaci√≥n usada es **postfija**, donde los operandos van primero y luego los operadores. Ejemplo:

```
Infix:     (1 + 2) * 3
Postfijo:  1 2 + 3 *
```

Esto **elimina la necesidad de par√©ntesis** o reglas de precedencia:

* El orden de los operandos y operadores **ya implica la estructura**.
* Por tanto, **no hay posibilidad de interpretaci√≥n alternativa**.

---

### ‚úÖ Conclusi√≥n

La gram√°tica:

* ‚úÖ **No es ambigua**, porque no hay conflictos en la tabla SLR.
* ‚úÖ Usa una notaci√≥n postfija que asegura una √∫nica interpretaci√≥n.

Por lo tanto, se puede afirmar con certeza que esta gram√°tica es **no ambigua**.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

**Ejercicio 7: Definici√≥n Dirigida por la Sintaxis (DDS) y atributos**

---

### üéì Teor√≠a previa: DDS, atributos y gram√°ticas atribu√≠das

Una **DDS** (Definici√≥n Dirigida por la Sintaxis) es una gram√°tica extendida con **atributos** y **reglas sem√°nticas** asociadas a las producciones.

* Un **atributo sintetizado** se calcula de los hijos hacia el padre.
* Un **atributo heredado** se pasa del padre a los hijos.

Clasificaci√≥n:

* Una gram√°tica **S-atribuida** usa solo atributos sintetizados.
* Una gram√°tica **L-atribuida** puede usar ambos, siempre que no haya dependencias hacia la derecha entre hermanos.

---

### a) Tabla de atributos definidos

| S√≠mbolo | Atributo | Dato | Tipo        | Comentario                                            |
| ------- | -------- | ---- | ----------- | ----------------------------------------------------- |
| E'      | res      | int  | Sintetizado | Valor resultado de la expresi√≥n en notaci√≥n postfija. |
| E       | v        | int  | Sintetizado | Valor representado por el nodo E.                     |
| N       | v        | int  | Sintetizado | Valor representado por el nodo N.                     |


---

###  Reglas sem√°nticas

| Regla de producci√≥n | Regla sem√°ntica                                      |
| ------------------- | ---------------------------------------------------- |
| E' ‚Üí E              | E'.res = E.v;                                        |
| E ‚Üí E‚ÇÅ E‚ÇÇ +         | E.v = E‚ÇÅ.v + E‚ÇÇ.v;                                   |
| E ‚Üí E‚ÇÅ E‚ÇÇ -         | E.v = E‚ÇÅ.v - E‚ÇÇ.v;                                   |
| E ‚Üí E‚ÇÅ !            | E.v = 1;  for (i = 2; i ‚â§ E‚ÇÅ.v; i++) E.v = E.v \* i; |
| E ‚Üí N               | E.v = N.v;                                           |
| N ‚Üí s(N)            | N.v = N‚ÇÅ.v + 1;                                      |
| N ‚Üí 0               | N.v = 0;                                             |


---

### b) Ejemplo de entrada: `s(0)s(0)+!`

Vamos a ver el √°rbol anotado (resumen):

```
              E'
            .v = 2
              |
              E
            .v = 2
              |
              E
            .v = 2
           /    \
         E       !
       .v = 2
     /    \
   E       +
 .v = 1   .v = 1
  |         |
  N         N
.v = 1    .v = 1
 / | \     / | \
s  ( N )   s  ( N )
     |         |
  N .v=0     N .v=0
     |         |
     0         0
```

Valor final (E.res) = 2

---

### c) Clasificaci√≥n de la DDS

* ‚úÖ **S-atribuida**: todos los atributos son sintetizados.
* ‚úÖ **L-atribuida**: cumple la condici√≥n porque no hay dependencias hacia la derecha entre hermanos ni uso de atributos heredados.

---

### ‚úÖ Conclusi√≥n

La gram√°tica con la DDS definida:

* Es **S-atribuida** ‚úÖ
* Es **L-atribuida** ‚úÖ

Esto facilita la implementaci√≥n de analizadores sem√°nticos en compiladores reales.

---



